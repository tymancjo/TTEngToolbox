<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Res Force Analyzer v2 (Batch Input)</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-color: #f8f9fa;
            --text-color: #333333;
            --accent-color: #d35400;
            --elec-color: #2980b9;
            --border-color: #e0e0e0;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.4rem; color: #2c3e50; font-weight: 700; }
        .subtitle { font-size: 0.9rem; color: #7f8c8d; margin-left: 10px; }

        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* SIDEBAR */
        .sidebar {
            width: 340px;
            background-color: var(--panel-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            overflow-y: auto;
            z-index: 5;
        }

        .control-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 0.9rem;
            color: #555;
        }

        .harmonics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .harmonic-input {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.8rem;
            background: #fdfdfd;
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        .harmonic-input input {
            width: 50px;
            border: none;
            border-bottom: 1px solid #ccc;
            text-align: right;
            font-weight: bold;
            color: var(--elec-color);
        }
        .harmonic-input input:focus { outline: none; border-bottom: 2px solid var(--elec-color); }

        .stats-box {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid var(--elec-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            font-size: 0.9rem;
        }

        button {
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            border: none;
            transition: 0.2s;
        }

        button.reset-btn {
            background-color: #555;
            color: white;
            padding: 10px;
            width: 100%;
            margin-top: auto;
        }
        button.reset-btn:hover { background-color: #333; }

        /* COLLAPSIBLE EDITOR STYLES */
        .collapsible-header {
            width: 100%;
            text-align: left;
            padding: 10px;
            background: #eee;
            border: 1px solid #ccc;
            color: #333;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
        }
        .collapsible-header:hover { background: #e0e0e0; }
        
        .collapsible-content {
            display: none;
            padding: 10px;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
        }
        
        .csv-textarea {
            width: 100%;
            height: 120px;
            font-family: monospace;
            font-size: 0.8rem;
            border: 1px solid #ccc;
            resize: vertical;
            box-sizing: border-box;
            padding: 5px;
            white-space: pre;
            overflow-y: auto;
            color: #333;
            background: #fafafa;
        }

        .apply-btn {
            background-color: var(--elec-color);
            color: white;
            padding: 8px;
            width: 100%;
            margin-top: 5px;
        }
        .apply-btn:hover { background-color: #1f618d; }
        
        .status-msg {
            font-size: 0.75rem; 
            margin-top: 5px; 
            min-height: 1rem;
        }

        /* DASHBOARD */
        .dashboard {
            flex: 1;
            padding: 20px;
            background-color: #f4f6f8;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
            min-height: 300px;
        }

        h3.chart-title {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #444;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            display: inline-block;
        }

        /* Loading Overlay */
        #loading {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
        }

    </style>
</head>
<body>

    <div id="loading">Calculating Physics...</div>

    <header>
        <div>
            <h1>Current & Force Physics Analyzer</h1>
            <span class="subtitle">High-Resolution I² Calculation & FFT</span>
        </div>
    </header>

    <div class="main-layout">
        <!-- SIDEBAR -->
        <div class="sidebar">
            <div class="stats-box">
                <div><strong>Fundamental:</strong> <span id="fund_disp">0</span> A</div>
                <div style="margin-top:5px;"><strong>Calculated THD:</strong> <span id="thd_disp" style="color:var(--elec-color)">0.00</span>%</div>
            </div>

            <!-- CSV Harmonic Input -->
            <div>
                <button class="collapsible-header" onclick="toggleEditor()">
                    <span>⚡ Harmonic Setup (CSV)</span>
                    <span id="arrow">▼</span>
                </button>
                <div id="harmonic-panel" class="collapsible-content">
                    <div style="font-size: 0.75rem; color: #666; margin-bottom: 5px;">
                        Format: <code>Order, Amps</code> (e.g. <code>5, 84</code>)
                    </div>
                    <textarea id="harmonicCsvInput" class="csv-textarea" spellcheck="false"></textarea>
                    <button class="apply-btn" onclick="parseAndApplyHarmonicCSV()">Apply Harmonics</button>
                    <div id="harmonic-status" class="status-msg"></div>
                </div>
            </div>

            <div class="control-group">
                <label>Manual Input (Amps)</label>
                <div class="harmonics-grid" id="harmonics_container"></div>
            </div>

            <button class="reset-btn" onclick="resetDefaults()">Reset Defaults</button>
        </div>

        <!-- DASHBOARD -->
        <div class="dashboard">
            
            <!-- Chart 1: Current Waveform -->
            <div class="chart-card">
                <h3 class="chart-title" style="border-color: var(--elec-color);">1. Input Current Waveform</h3>
                <div id="plotCurrent" style="width:100%; height:300px;"></div>
            </div>

            <!-- Chart 2: Force Waveform -->
            <div class="chart-card">
                <h3 class="chart-title" style="border-color: var(--accent-color);">2. Mechanical Force Waveform (F ∝ I²)</h3>
                <div id="plotForce" style="width:100%; height:300px;"></div>
            </div>

            <!-- Chart 3: FFT Spectrum -->
            <div class="chart-card">
                <h3 class="chart-title" style="border-color: #8e44ad;">3. High-Res Force Spectrum (Smoothed)</h3>
                <div id="plotSpectrum" style="width:100%; height:500px;"></div>
            </div>

        </div>
    </div>

<script>
    // ==========================================
    // 1. SYSTEM CONFIG
    // ==========================================
    const BASE_FREQ = 50; 
    const SAMPLE_RATE = 10240; 
    const NUM_SAMPLES = 65536; // 65k points for smooth FFT
    const MIN_DB = -120;

    // Default Harmonics
    const defaultHarmonics = [0, 700, 0, 2, 0, 8, 0, 7, 0, 11, 0, 0, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7];
    while(defaultHarmonics.length < 26) defaultHarmonics.push(0);

    let harmonics = [...defaultHarmonics];
    let debounceTimer;

    // ==========================================
    // 2. MATH & DSP FUNCTIONS
    // ==========================================
    
    // Iterative Radix-2 FFT
    function fft_iterative(real, imag) {
        const n = real.length;
        let j = 0;
        for (let i = 0; i < n - 1; i++) {
            if (i < j) {
                [real[i], real[j]] = [real[j], real[i]];
                [imag[i], imag[j]] = [imag[j], imag[i]];
            }
            let k = n >> 1;
            while (k <= j) {
                j -= k;
                k >>= 1;
            }
            j += k;
        }
        for (let size = 2; size <= n; size <<= 1) {
            const half = size >> 1;
            const angle = -2 * Math.PI / size;
            const w_r = Math.cos(angle);
            const w_i = Math.sin(angle);
            for (let i = 0; i < n; i += size) {
                let u_r = 1.0, u_i = 0.0;
                for (let k = 0; k < half; k++) {
                    const even = i + k;
                    const odd = i + k + half;
                    const t_r = u_r * real[odd] - u_i * imag[odd];
                    const t_i = u_r * imag[odd] + u_i * real[odd];
                    real[odd] = real[even] - t_r;
                    imag[odd] = imag[even] - t_i;
                    real[even] = real[even] + t_r;
                    imag[even] = imag[even] + t_i;
                    const next_u_r = u_r * w_r - u_i * w_i;
                    u_i = u_r * w_i + u_i * w_r;
                    u_r = next_u_r;
                }
            }
        }
    }

    function applyBlackmanWindow(data) {
        const n = data.length;
        const windowed = new Float32Array(n);
        const a0 = 0.42, a1 = 0.5, a2 = 0.08;
        for(let i=0; i<n; i++) {
            const w = a0 - a1*Math.cos(2*Math.PI*i/(n-1)) + a2*Math.cos(4*Math.PI*i/(n-1));
            windowed[i] = data[i] * w;
        }
        return windowed;
    }

    function harmonicsToCSV(harmArr) {
        let lines = [];
        harmArr.forEach((val, order) => {
            if(val > 0) lines.push(`${order}, ${val}`);
        });
        return lines.join('\n');
    }

    // ==========================================
    // 3. UI LOGIC (CSV & Sidebar)
    // ==========================================
    
    function toggleEditor() {
        const panel = document.getElementById('harmonic-panel');
        const arrow = document.getElementById('arrow');
        if (panel.style.display === 'block') {
            panel.style.display = 'none';
            arrow.textContent = '▼';
        } else {
            panel.style.display = 'block';
            // Sync text box with current state
            document.getElementById('harmonicCsvInput').value = harmonicsToCSV(harmonics);
            arrow.textContent = '▲';
        }
    }

    function msg(text, color) {
        const el = document.getElementById('harmonic-status');
        el.textContent = text;
        el.style.color = color;
        setTimeout(() => el.textContent = '', 3000);
    }

    function parseAndApplyHarmonicCSV() {
        const rawText = document.getElementById('harmonicCsvInput').value;
        const lines = rawText.split('\n');
        
        let maxOrder = 25;
        for(let line of lines) {
            const parts = line.split(',');
            if(parts.length >= 2) {
                const o = parseInt(parts[0]);
                if(o > maxOrder) maxOrder = o;
            }
        }
        
        // Cap max order to prevent memory issues if user pastes crazy data
        if(maxOrder > 200) maxOrder = 200;

        let newHarmonics = new Array(maxOrder + 1).fill(0);
        let count = 0;

        for (let line of lines) {
            line = line.trim();
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length >= 2) {
                const order = parseInt(parts[0]);
                const amp = parseFloat(parts[1]);
                if (!isNaN(order) && !isNaN(amp) && order >= 0 && order <= maxOrder) {
                    newHarmonics[order] = amp;
                    count++;
                }
            }
        }

        if(count === 0) {
            msg("Error: No valid data found.", 'red');
            return;
        }

        harmonics = newHarmonics;
        renderGrid();
        updatePlots();
        msg(`Updated! Loaded ${count} harmonics.`, 'green');
    }

    function renderGrid() {
        const grid = document.getElementById('harmonics_container');
        grid.innerHTML = '';
        harmonics.forEach((val, idx) => {
            // Only show up to 25 or non-zero higher orders to save space
            if (idx > 25 && val === 0) return;

            let div = document.createElement('div');
            div.className = 'harmonic-input';
            let label = idx === 0 ? 'DC' : (idx === 1 ? '50Hz' : `${idx}th`);
            if(idx === 1) label = '<b>50Hz</b>';
            
            div.innerHTML = `
                <span>${label}</span> 
                <input type="number" min="0" step="1" value="${val}" 
                onchange="triggerUpdate(${idx}, this.value)">
            `;
            grid.appendChild(div);
        });
    }

    // ==========================================
    // 4. SIMULATION ENGINE
    // ==========================================
    function runAnalysis() {
        
        const current = new Float32Array(NUM_SAMPLES);
        const force = new Float32Array(NUM_SAMPLES);
        const dt = 1 / SAMPLE_RATE;

        const activeHarmonics = [];
        harmonics.forEach((amp, order) => {
            if(amp !== 0) activeHarmonics.push({order, amp, omega: 2 * Math.PI * order * BASE_FREQ});
        });

        for(let i=0; i<NUM_SAMPLES; i++) {
            const t = i * dt;
            let val = 0;
            for(let h of activeHarmonics) {
                val += h.amp * Math.cos(h.omega * t);
            }
            current[i] = val;
            force[i] = val * val;
        }

        // Stats
        let fund = harmonics[1] || 0;
        let sumSq = 0;
        for(let h=2; h<harmonics.length; h++) sumSq += harmonics[h]**2;
        let thd = fund > 0 ? (Math.sqrt(sumSq) / fund) * 100 : 0;
        
        document.getElementById('fund_disp').innerText = fund;
        document.getElementById('thd_disp').innerText = thd.toFixed(2);

        // FFT
        const real = applyBlackmanWindow(force); 
        const imag = new Float32Array(NUM_SAMPLES).fill(0);
        fft_iterative(real, imag);

        // Magnitude
        const maxFreqIdx = Math.floor(4000 / (SAMPLE_RATE / NUM_SAMPLES));
        const fftFreqs = new Float32Array(maxFreqIdx);
        const fftDb = new Float32Array(maxFreqIdx);
        
        const binWidth = SAMPLE_RATE / NUM_SAMPLES;
        const normFactor = NUM_SAMPLES / 2; 

        let maxMag = 0;
        const magnitudes = new Float32Array(maxFreqIdx);
        for(let i=0; i<maxFreqIdx; i++) {
            const mag = Math.sqrt(real[i]**2 + imag[i]**2) / normFactor;
            magnitudes[i] = mag;
            if(i > 20 && mag > maxMag) maxMag = mag; 
        }
        if(maxMag === 0) maxMag = 1e-9;

        for(let i=0; i<maxFreqIdx; i++) {
            fftFreqs[i] = i * binWidth;
            let db = 20 * Math.log10((magnitudes[i] + 1e-12) / maxMag);
            if(db < MIN_DB) db = MIN_DB;
            fftDb[i] = db;
        }

        const displayCount = Math.floor(0.06 * SAMPLE_RATE);
        const timeDisplay = new Float32Array(displayCount);
        for(let i=0; i<displayCount; i++) timeDisplay[i] = i * dt * 1000;

        return {
            time: timeDisplay,
            current: current.subarray(0, displayCount),
            force: force.subarray(0, displayCount),
            spectrum: { x: fftFreqs, y: fftDb }
        };
    }

    // ==========================================
    // 5. PLOTTING & INIT
    // ==========================================
    function updatePlots() {
        document.getElementById('loading').style.display = 'block';
        
        setTimeout(() => {
            const data = runAnalysis();
            const config = { responsive: true, displayModeBar: false };

            // 1. CURRENT
            Plotly.react('plotCurrent', [{
                x: data.time, y: data.current,
                type: 'scatter', mode: 'lines',
                line: { color: '#2980b9', width: 2 }
            }], {
                margin: { t: 10, r: 10, b: 40, l: 60 },
                xaxis: { title: 'Time (ms)', color: '#666' },
                yaxis: { title: 'Current (A)', color: '#2980b9' },
                paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)'
            }, config);

            // 2. FORCE
            Plotly.react('plotForce', [{
                x: data.time, y: data.force,
                type: 'scatter', mode: 'lines', fill: 'tozeroy',
                line: { color: '#d35400', width: 2 },
                fillcolor: 'rgba(211, 84, 0, 0.1)'
            }], {
                margin: { t: 10, r: 10, b: 40, l: 60 },
                xaxis: { title: 'Time (ms)', color: '#666' },
                yaxis: { title: 'Force (I²)', color: '#d35400' },
                paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)'
            }, config);

            // 3. SPECTRUM
            const peakX = [], peakY = [], peakTxt = [];
            const y = data.spectrum.y;
            const x = data.spectrum.x;
            
            for(let i=5; i<y.length-5; i++) {
                if(y[i] > -60 && y[i] > y[i-1] && y[i] > y[i+1]) {
                    let isPeak = true;
                    for(let k=-4; k<=4; k++) { if(y[i+k] > y[i]) isPeak = false; }
                    if(isPeak) {
                        peakX.push(x[i]);
                        peakY.push(y[i]);
                        peakTxt.push(`${Math.round(x[i])}Hz<br>${y[i].toFixed(1)}dB`);
                    }
                }
            }

            Plotly.react('plotSpectrum', [
                {
                    x: data.spectrum.x, y: data.spectrum.y,
                    type: 'scatter', mode: 'lines',
                    line: { color: '#8e44ad', width: 1 },
                    name: 'Spectrum'
                },
                {
                    x: peakX, y: peakY, mode: 'markers', type: 'scatter',
                    marker: { color: '#333', size: 6 },
                    text: peakTxt, hoverinfo: 'text', showlegend: false
                }
            ], {
                margin: { t: 10, r: 20, b: 50, l: 60 },
                xaxis: { 
                    type: 'log', title: 'Frequency (Hz)', color: '#666',
                    range: [Math.log10(20), Math.log10(4000)] 
                },
                yaxis: { 
                    title: 'Magnitude (dB)', color: '#8e44ad',
                    range: [MIN_DB, 5]
                },
                paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
                shapes: [
                    { type:'line', x0: 100, x1: 100, y0: MIN_DB, y1: 5, line:{color:'#ccc', width:1, dash:'dot'} },
                    { type:'line', x0: 300, x1: 300, y0: MIN_DB, y1: 5, line:{color:'#ccc', width:1, dash:'dot'} },
                    { type:'line', x0: 500, x1: 500, y0: MIN_DB, y1: 5, line:{color:'#ccc', width:1, dash:'dot'} }
                ]
            }, config);

            document.getElementById('loading').style.display = 'none';
        }, 10);
    }

    function triggerUpdate(idx, val) {
        harmonics[idx] = parseFloat(val) || 0;
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(updatePlots, 300);
    }

    function resetDefaults() {
        harmonics = [...defaultHarmonics];
        renderGrid();
        updatePlots();
    }

    function init() {
        renderGrid();
        updatePlots();
    }

    init();

</script>
</body>
</html>